%\VignetteIndexEntry{UsingRDataTracker} 

% This file was converted to LaTeX by Writer2LaTeX ver. 1.2
% see http://writer2latex.sourceforge.net for more info

% Conversion and modifications by Luis Perez 3-Aug-2014
\documentclass[12pt]{article}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{colorlinks=true, linkcolor=blue, citecolor=blue, filecolor=blue, urlcolor=blue, pdftitle=}

% Set up the margins
\usepackage[margin=1in]{geometry}

% Using packages to display R Code
\usepackage{listings}

% Setting up the title
\title{Using RDataTracker}
\author{
        Barbara Lerner \\
                Department of Computer Science\\
        Mount Holyoke College\\
        50 College St, South Hadley, MA
            \and
        Emery Boose\\
        Harvard Forest\\
        Harvard University\\
        322 North Main Street, Petersham, MA \\
}
\date{\today}

% Pagestyle
\setlength{\headheight}{15pt}
\usepackage{fancyhdr}
\pagestyle{fancy}

% Page header
\fancyhead[R]{Using  RDataTracker}

% Page footer
\pagenumbering{arabic}

% R Code
\lstset{
language=R,
basicstyle=\scriptsize\ttfamily,
commentstyle=\ttfamily\color{gray},
numbers=left,
numberstyle=\ttfamily\color{gray},
stepnumber=1,
numbersep=5pt,
backgroundcolor=\color{white},
showspaces=false,
showstringspaces=false,
showtabs=false,
frame=single,
tabsize=2,
captionpos=b,
breaklines=true,
breakatwhitespace=false,
title=\lstname,
escapeinside={},
keywordstyle={},
morekeywords={},
mathescape
}

\begin{document}

\maketitle

\newpage
\tableofcontents
\newpage

\section{What is RDataTracker?}

RDataTracker is a library of R functions that can be used to annotate (instrument) an R script in order to collect data provenance in the form of a Data Derivation Graph (DDG) as the script executes. It can also be used to collect data provenance during R console sessions. RDataTracker saves the DDG as a text file (ddg.txt), with ancillary files stored in a special DDG directory. The DDG can then be viewed, stored, and queried using a separate tool, DDG Explorer (see Using DDG Explorer for more information on this tool).

\section{What is a DDG?}

A Data Derivation Graph (DDG) is a mathematical graph that captures the history of a data analysis. The DDG consists of nodes and edges. In DDG Explorer, nodes are shown as ovals and edges are shown as arrows (see below for examples). Different colors (explained in the legend for DDG Explorer) are used to indicate different types of nodes and edges.
\bigskip

There are two major types of nodes---procedural nodes and data nodes---and two major types of edges---control flow edges and data flow edges. Control flow edges indicate how control passes from one procedural node to another procedural node as the script executes. Data flow edges indicate how input data pass from a data node to a procedural node or how output data pass from a procedural node to a data node.


\bigskip

Procedural nodes include Operational, Collapsible, Expandable, Binding, Checkpoint, and Restore nodes. Operational nodes perform an operation. Collapsible nodes and expandable nodes provide a level of abstraction by allowing a section of the DDG to be expanded or collapsed. Binding nodes indicate the process of binding input parameters of a function to its internal representation. Checkpoint nodes indicate creation of a checkpoint. Restore nodes indicate that a previous checkpoint was restored.


\bigskip

Data nodes include Data, File, Snapshot, URL, and Exception nodes. Data nodes are used for simple values. File nodes are used for files that are inputs to the R script or created by the R script. Snapshot nodes are used for complex data values such as data frames, as well as other complex data, such as graphical outputs. URL nodes are used for URL addresses. Exception nodes are used for error messages. The values of Data, URL, and Exception nodes are stored in the DDG text file. The values of File and Snapshot nodes are stored as files in the DDG directory.


\bigskip

For more details on DDGs and how to view, store, and query them, please see the DDG Explorer documentation (UsingDDGExplorer.pdf).


\section{Installation and Use}

The following instructions assume you are using RStudio. Example scripts are shown demarcated in a code box. See Section 6 for DDG examples.


\bigskip

RDataTracker is distributed as an R package. Note that R packages must be \textit{installed} to your computer (normally just once) and then \textit{loaded} for use in a particular session.


\bigskip

To install RDataTracker, copy or download the package file to your computer, open RStudio, and use the Tools / Install Packages option to install from a Package Archive File (alternatively you can use the \textbf{install.packages} command at the R prompt). The library depends on \textbf{gtools}, so make sure this is installed before attempting installation of RDataTracker. Once the library has been installed, select Packages / RDataTracker to see a list of help pages for the various functions. Note that all functions begin with \textbf{ddg.} to avoid confusion with function names in the main script.


\bigskip

To load RDataTracker, use the \textbf{library(RDataTracker)} or the \textbf{require(...)} command at the R prompt or at the top of your script. Alternatively you can click on the checkbox for RDataTracker in the list of packages in RStudio. The library needs to know the path and name of the R script itself and the path for the DDG files that will be created (see below for how to provide this information). We recommend specifying a DDG directory separate from the working directory for each R script. 

\bigskip

A DDG is created by adding function calls to RDataTracker as described below. Once the script is properly annotated, data provenance will be collected as the R script executes. This information is stored in memory and written to the DDG file (\textbf{ddg.txt}) on the DDG directory when the R script finishes. The DDG file contains information about the computing environment, the number of procedural steps, and the specifications for individual nodes and edges of the DDG. Step and data nodes are each numbered in sequence beginning with one. Simple data values (e.g. numbers) are stored in the DDG itself. More complex data values (e.g. data frames) are stored as pointers to files created on the DDG directory. Input and output files of the main script are stored as pointers to copies of those files created on the DDG directory. While the DDG file can be viewed using a text editor, its primary purpose is to support exchange of information and it should normally be viewed and queried using DDG Explorer.


\bigskip

The library functions are introduced below. For more details, please see the help pages under Packages -> RDataTracker in RStudio.


\subsection{Minimal Annotations}
This section describes different approaches to directly annotating R commands for provenance collection, either taken from an existing R script file or input directly into the R console.

\subsubsection{Short Scripts and Console Sessions}
For short scripts or console sessions not exceeding \textit{R\_HISTSIZE} (default of 512 lines), a simple DDG can be created with minimal additional commands, as illustrated below:

\begin{lstlisting}
# load the library
library(RDataTracker)

# Set the working directory and obtain the path of the script and the ddg directory
setwd("c:/data/r/example")
r.script.path <- paste(getwd(), "test.r", sep="")
ddgdir <- paste(getwd(), "/ddg", sep="")

# Initialize the data collection
ddg.init(r.script.path, ddgdir)

# main script or console commands
{short script or set of console commands}

# Save the collected data to disk, and delete the DDG in memory (quit=TRUE parameter)
ddg.save(quit=TRUE)
\end{lstlisting}


Here the first line loads the RDataTracker package. The second line sets the working directory. The third line specifies the path and name of the R script. The fourth line specifies the directory where the DDG files will be stored. The fifth line initiates creation of a DDG. This is followed by the normal script or console session commands. The final line saves the DDG.

\bigskip

When \textbf{enable.console}, an optional parameter to \textbf{ddg.init} is set to TRUE, the library captures assignment statements as Operational nodes and associated data values as Data nodes. This approach is useful for getting a quick view of a data analysis and is therefore the default. However, the above approach to annotations is limited to short scripts (usually below 512 lines, as specified by \textit{R\_HISTSIZE}). 

\bigskip

\subsubsection{Longer Scripts and Console Sessions}
\label{section:minimal-annotations}

\bigskip

A similar approach can be used to capture longer console sessions or scripts in R.

\begin{lstlisting}
# load the library
library(RDataTracker)

# Set the working directory and obtain the path of the script and the ddg directory
setwd("c:/data/r/example")
r.script.path <- paste(getwd(), "test.r", sep="")
ddgdir <- paste(getwd(), "/ddg", sep="")

# Initialize the data collection
ddg.init(r.script.path, ddgdir)

# console or script commands go here (approx 512 lines by default, no more)
{script or console commands}

# captures previous set of commands and stores in memory
ddg.grabhistory()

# additional console or script commands
{console or script commands}

# captures previous history, and writes out current ddg to disk
ddg.save()

# more commands
{console or script commands}

# Save the additionally collected data to disk, and mark the DDG as completed
ddg.save(quit=TRUE)
\end{lstlisting}

Here the first line loads the RDataTracker package. The following three lines of code initiate the creation of a DDG and specify where the DDG files will be stored.

\bigskip

The user is then free to input his or her commands, either through the console or from a script. Note that data capture occurs only during calls to functions from the RDataTracker package. This limits the ability to capture data since the state of the environment is unknown between calls to RDataTracker functions. For example, if a variable is ever reused, only the value at the time of data capture is available. This problem can be mitigated with multiple calls to RDataTracker functions. However, it is recommended to see either Section \ref{section:script_provenance} or Advanced Annotations \ref{part:source} as those approaches, while limited only to scripts, avoid this issue entirely.

\bigskip

If advanced annotations are avoided, two functions exist for the purpose of capturing data. The \textbf{ddg.grabhistory} may be called more than once during a console session or script execution and will add to the current DDG without writing the output to disk. \textbf{ddg.save} without any parameters works similarly, but writes out all data to disk.

\bigskip

A call to \textbf{ddg.save} with the \textit{quit} parameter as TRUE will write out all data to disk and clear out the current DDG from memory. A call to \textbf{ddg.init} will replace the current DDG with a new DDG without writing or capturing any additional data for the previous DDG.


\subsection{Advanced Annotations}
A more defined DDG may be created by adding more annotations to the original script or console commands. Here \textbf{enable.console} can be set to FALSE in \textbf{ddg.init} and only the annotated portions of the script appear in the DDG. However, it is still recommended to leave enable.console set to TRUE and simply annotate functions, as this will allow for automatic provenance capture for the top level as well as detailed provenance of function calls.


\bigskip

The basic strategy for advanced annotations is described below. See the help files for RDataTracker for additional details on individual functions.

\begin{enumerate}
\item Data nodes for input data to the original script are created using \textbf{ddg.data}, \textbf{ddg.file}, \textbf{ddg.url}, or \textbf{ddg.exception}, depending on the data type. If only the variable name is supplied, the library will look up its value in the current environment.
\begin{lstlisting}
ddg.data(x)
\end{lstlisting}

\item Operational nodes are created using \textbf{ddg.procedure}. If \textbf{ddg.procedure} is called from inside an R function and the name of the node is omitted, the library will use the name of the function.

\begin{lstlisting}
ddg.procedure()
\end{lstlisting}

\item Input data nodes are assumed to exist when \textbf{ddg.procedure} is called. Data flow edges to one or more existing input data nodes can be created using a list of values and the \textbf{ins} parameter of \textbf{ddg.procedure}. 

\begin{lstlisting}
ddg.procedure(ins=list("x1", "x2))
\end{lstlisting}


If \textbf{ddg.procedure} is called from inside an R function and if \textbf{lookup.ins} is set to TRUE, the library will create a data flow edge to each argument passed to the function, if a corresponding data node exists.
\begin{lstlisting}
ddg.procedure(lookup.ins=TRUE)
\end{lstlisting}

A data flow edge to an existing data node may also be created using \textbf{ddg.data.in}. The name of operational node may be omitted if \textbf{ddg.data.in }is called from within an R function.

\begin{lstlisting}
ddg.procedure()
ddg.data.in(x)
\end{lstlisting}

\item One or more output data nodes and corresponding data flow edges may be created using a list of values and the \textbf{outs.data}, \textbf{outs.file}, \textbf{outs.url}, or \textbf{outs.exception}, \textbf{outs.graphic} parameters of \textbf{ddg.procedure}, depending on the data type.

\begin{lstlisting}
ddg.procedure(outs.data=list("z1", "z2"), outs.graphic="graphic.file")
\end{lstlisting}


A single output data node and corresponding data flow edge may also be created using \textbf{ddg.data.out}, \textbf{ddg.file.out}, \textbf{ddg.graphic.out}, \textbf{ddg.url.out}, or \textbf{ddg.exception.out}, depending on the data type. The name of the operational node may be omitted if \textbf{ddg.data.out}, etc is called from within an R function.

\begin{lstlisting}
ddg.procedure()
ddg.data.out(x)
\end{lstlisting}

\item Return values from functions can also be captured, and appropriate binding nodes created, using \textbf{ddg.return}. 
\begin{lstlisting}
# function definition, replace return with ddg.return
f <- function() {
  {R Function Code}
  ddg.return(x)
}
\end{lstlisting}


The above would create binding nodes with any variable to which the result of f is assigned. 

\bigskip

\item Expandable and collapsible nodes, implemented through calls to \textbf{ddg.start} and \textbf{ddg.finish}, may be used to create levels of abstraction in the DDG. These functions must be correctly nested with matching arguments.

\begin{lstlisting}
ddg.start("calculate.square.root")

# intervening R code
{intervening R code}

ddg.finish("calculate.square.root")
\end{lstlisting}


Clicking on the start or finish node in DDG Explorer will collapse the intervening nodes to a single node, while clicking on a single collapsed node will expand to reveal the intervening nodes.


\bigskip
\item The automatic capture of data, also known as enabling \textbf{console mode}, can be turned on and off dynamically using \textbf{ddg.console.on} and \textbf{ddg.console.off}. Commands captured during an enabled console are encapsulated in a collasible Console node. 
\begin{lstlisting}

# turn on the console mode (if alread on, nothing occurs)
ddg.console.on()

# captured R code
{captured R code}

# turn it off
ddg.console.off()

# no automatic capturing occurs here
{R code}

# Nothing occurs since console is already off
ddg.console.off()

\end{lstlisting}
From the above, a single collapsible console node is created including the captured R code.

\bigskip

\item DDGs generated from sourced files can be nested within the larger DDG of the script or console commands if any calls to \textbf{source} are replaced by calls to \textbf{ddg.source}. Both commands take similar optional parameters. 
\label{part:source}
\begin{lstlisting}
# source a script
ddg.source("script.r")
\end{lstlisting}
The above would create a collapsible ``script.r'' node. Within this node, a DDG that would have normally been generated from copying and pasting the code from "script.r" into the current script. By default, calls from within the sourced script to the library are ignored. For more detail, see the library documentation. 

Furthermore, note that any script sourced in this way avoid the issue of data capture discussed in section \ref{section:minimal-annotations}, as we always have access to the scripts environment.

\bigskip


\item A DDG is created and saved using the \textbf{ddg.init} and \textbf{ddg.save} functions. The annotation is essentially the same as for the minimal DDG described above, except that \textbf{enable.console} can be set to FALSE.

\begin{lstlisting}
# load the library
library(RDataTracker)

# Set the working directory and obtain the path of the script and the ddg directory
setwd("c:/data/r/example")
r.script.path <- paste(getwd(), "test.r", sep="")
ddgdir <- paste(getwd(), "/ddg", sep="")

# Initialize the data collection
ddg.init(r.script.path, ddgdir, enable.console=FALSE)

# main script or annotated console commands
{short script or set of console commands, annotated}

# Save the collected data to disk, and delete the DDG in memory (quit=TRUE parameter)
ddg.save(quit=TRUE)
\end{lstlisting}

Alternatively, \textbf{ddg.run} can be used instead of \textbf{ddg.init} and \textbf{ddg.save} if the main program is implemented as a single function. One advantage to this approach is that if an R error occurs during execution of the function, the error will be captured in an Exception node in the DDG.
\begin{lstlisting}
# load the library
library(RDataTracker)

# R script functions
{R script functions}

main <- function {
	# R script main program
	{R script main program}
}

# Set the working directory and obtain the path of the script and the ddg directory
setwd("c:/data/r/example")
r.script.path <- paste(getwd(), "test.r", sep="")
ddgdir <- paste(getwd(), "/ddg", sep="")

# Run the main function and collect data
ddg.run(r.script.path, ddgdir,main, enable.console=FALSE)

\end{lstlisting}
\end{enumerate}

\subsection{Data Provenance from Scripts}
\label{section:script_provenance}
If a clean, stand-alone script already exists for the process from which provenance needs to be collected, a final option exists. The advantages of this option are numerous. The approach is:
\begin{enumerate}
\item Compatible. This approach can be used in conjunction with the advanced annotations described above, as well as with the minimal annotations. 
\item Simple. The process of collecting data provenance can be done with a single command, no annotations required.
\item Minimal. Similar to the \textbf{ddg.run} example, calls to \textbf{ddg.init} and \textbf{ddg.save} are unnecessarsy.
\item Correct. The problem of data collection without calls to the library is solved.
\item Fast. 
\end{enumerate}
The script must be either clean (without annotations) or annotated without the use of \textbf{ddg.run}, as this will could to issues) Then running the following commands from the console (or an R script) will create a DDG for the script..
\begin{lstlisting}
# Set the working directory (or provide full path to script)
setwd("c:/data/r/example")

# Execute the script and collect data on it
ddg.run("script.r")
\end{lstlisting}
This executes the script and creates a DDG. By default, calls to \textbf{ddg.run} and \textbf{ddg.init} in ``script.r'' are ignored.


\subsection{Checkpoint and Restore}

Included with the library is a file \textbf{DDGCheckpoint.R} which contains functions that can be used to save and restore the R state and file system state, allowing a user to return to the environment present at an earlier point in the data analysis. \textbf{ddg.checkpoint} adds a checkpoint node and a snapshot node and returns the full path to the file containing the saved state. \textbf{ddg.restore} adds a restore node with an input edge from the snapshot node for the saved checkpoint file. A given checkpoint can be restored more than once.

\begin{lstlisting}
# source the file, assuming it's in the working directory
source("DDGExplorer.R")

# create checkpoint
checkpoint1 <- ddg.checkpoint()

# intervening R code
{intervening R code}

# restore the checkpoint
restore(checkpoint1)
\end{lstlisting}
Note that in order to use these functions, DDGCheckpoint.R must be sourced. It is \textbf{not} included in the RDataTracker library. 
\section{Troubleshooting}

\bigskip

Annotation errors are generally captured by the library and stored as error nodes in the DDG. The same is true for error messages from the R interpreter if the \textbf{ddg.run} function is used as described above. These features can be useful for troubleshooting the original script and the associated annotations.


\bigskip

The \textbf{ddg.debug.on} and \textbf{ddd.debug.off} functions may be used (in a script or at the console) to turn debugging on and off. Debugging is off by default. When debugging is turned on, details related to creation of the DDG are displayed in the console as the script executes.


\bigskip

The contents of the current DDG directory (if different from the working directory) may be deleted by calling the \textbf{ddg.flush.ddg} function at the R prompt.

\section{Acknowledgements}


This material is based upon work supported by the National Science Foundation under Awards No. CCR-0205575, CCR-0427071, and IIS-0705772, the National Science Foundation REU grants DBI-0452254 and DBI-1003938, the Mount Holyoke Center for the Environment Summer Leadership Fellowships, and the Charles Bullard Fellowship in Forest Research at the Harvard Forest. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the National Science Foundation, Mount Holyoke College or Harvard University.

Numerous students have been involved in the research and tool development through the REU program at Harvard Forest. They are Shay Addams (2013 REU), Vasco Carinhas (2013 REU), Xiang Zhao (University of Massachusetts, Amherst), Luis Antonio Perez (2014 REU), and Nicole Hoffler (2014 REU).

\section{DDG Examples}

{\centering  \includegraphics[width=5.4in,height=3.7547in]{UsingRDataTracker-img/UsingRDataTracker-img003.jpg} \par}

{\centering  \includegraphics[width=4.4252in,height=3.5744in]{UsingRDataTracker-img/UsingRDataTracker-img004.jpg} \par}


\newpage

\section{Technical Details}

\subsection{Syntax of DDG Text File}

\begin{lstlisting}
<DDG> -> <Attributes>*<PinCounter> <Declaration>*
     
<Declaration> -> <EdgeDecl> | <NodeDecl>

<EdgeDecl> -> <ControlFlowDecl> | <DataFlowDecl>

<ControlFlowDecl> -> <CF_TOKEN> <ProcedureNodeID><ProcedureNodeID>

<DataFlowDecl> -> <DF_TOKEN> <DataFlowEdgeDecl>

<DataFlowEdgeDecl> -> <DataNodeID><ProcedureNodeID> | <ProcedureNodeID><DataNodeID>

<NodeDecl> -> <DataNode> | <ProcedureNode>

<ProcedureNode> -> <ProcedureNodeType> <ProcedureNodeID> <NAME> ["Value" "="<Value> ] ["Time" "=" <Timestamp> ][";"]

<ProcedureNodeType> -> "Operation" | "Start" | "Finish" | "Binding" | "Checkpoint" | "Restore"

<DataNode> -> <DataNodeType> <DataNodeID> <NAME> ["Value" "="<Value> ] ["Time" "=" <Timestamp> ] ["Location" "=" <FILENAME>] [";"]

<DataNodeType> -> "Data" | "Exception" | "URL" | "File" | "Snapshot"

<Value> -> <URL> | <FILENAME> | <STRING>

<Timestamp> -> "<YEAR>-<MONTH>-<DATE>["T"<HOUR>"."<MINUTE>["."<SECOND> ["."<FRACTIONAL>]]]

<Attributes> -><NAME>["="]<AttrValue>

<AttrValue> -> <STRING>

<PinCounter> -> <INT>

<DataNodeID> -> "d" <INT>

<ProcedureNodeID> -> "p" <INT>

<CF_TOKEN> -> "CF"

<DF_TOKEN> -> "DF"
\end{lstlisting}

\end{document}
